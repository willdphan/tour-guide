# -*- coding: utf-8 -*-
"""web_voyager.ipynb
http://localhost:3000
Automatically generated by Colab.

uvicorn src.app.api.api:app --reload   
Able to recognize elemnts not visible on page.

User inputs a question or task.
An AI agent analyzes the current web page and decides on an action.
The chosen action (click, type, scroll, etc.) is executed using Playwright.
The page's response is observed and fed back to the agent.
This process repeats until the task is completed or an error occurs.
The agent provides a final answer to the user.
"""

import json
import os
import asyncio
import base64
import platform
import re
from typing import List, Optional, TypedDict, Dict
from dotenv import load_dotenv
from urllib.parse import urlparse
from langgraph.graph import END

from langchain_core.messages import BaseMessage, SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnablePassthrough, RunnableLambda, chain as chain_decorator
from langchain_openai import ChatOpenAI
from langchain import hub
from langgraph.graph import END, StateGraph
from playwright.async_api import Page, async_playwright, Error as PlaywrightError
from browserbase import Browserbase

import bs4
from bs4 import BeautifulSoup
from collections import Counter

from pydantic import BaseModel
from PIL import Image
import io

# Load environment variables
load_dotenv()
# Initialize Browserbase
browserbase = Browserbase()

# Set up environment variables
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_PROJECT"] = "Web-Voyager"
os.environ["LANGCHAIN_API_KEY"] = os.getenv("LANGCHAIN_API_KEY")
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

# Define types
class BBox(TypedDict):
    x: float
    y: float
    text: str
    type: str
    ariaLabel: str

class Prediction(TypedDict):
    action: str
    args: Optional[List[str]]

class AgentState(TypedDict):
    page: Page
    input: str
    img: str
    bboxes: List[BBox]
    prediction: Prediction
    scratchpad: List[BaseMessage]
    observation: str
    current_url: str
    action_history: List[dict]
    viewport_height: int
    html_content: str
    text_content: str
    content_analysis: dict
    screenshot: Optional[str]  # Base64 encoded screenshot

class ScreenLocation(BaseModel):
    x: float
    y: float
    width: float
    height: float

class Step(BaseModel):
    thought: str
    action: str
    instruction: str
    element_description: Optional[str] = None
    screen_location: Optional[dict] = None
    hover_before_action: bool = False
    text_input: Optional[str] = None
    duration: float = 2.0  # Default duration in seconds

class AgentResponse(BaseModel):
    steps: List[Step]
    final_answer: Optional[str] = None
    current_url: str

###############
# AGENT TOOLS #
###############

# Define tools
async def click(state: AgentState):
    page = state["page"]
    click_args = state["prediction"]["args"]

    if click_args is None or len(click_args) != 1:
        return f"Failed to click element with ID {click_args}"
    
    element_id = int(click_args[0])
    elements = state["content_analysis"]["elements"]

    if element_id < 0 or element_id >= len(elements):
        return f"Invalid element ID: {element_id}"
    
    element = elements[element_id]
    
    selector = None
    if element['html_id']:
        selector = f"#{element['html_id']}"
    elif element['name']:
        selector = f"[name='{element['name']}']"
    elif element['href']:
        selector = f"a[href='{element['href']}']"
    else:
        selector = f"{element['type']}:has-text('{element['text']}')"
    
    try:
        print(f"Attempting to click element with selector: {selector}")
        
        # First, try to scroll the element into view
        await page.evaluate(f"""
            (selector) => {{
                const element = document.querySelector(selector);
                if (element) {{
                    element.scrollIntoView({{behavior: 'smooth', block: 'center', inline: 'center'}});
                }}
            }}
        """, selector)
        
        # Wait a bit for any animations to complete
        await page.wait_for_timeout(1000)
        
        # Now try to click the element
        await page.click(selector, timeout=5000)
        
        return f"Clicked element with ID {element_id}"
    
    except Exception as e:
        print(f"Failed to click element with ID {element_id}: {str(e)}")
        print(f"Element details: {json.dumps(element, indent=2)}")
        
        # If click fails, try to execute click via JavaScript
        try:
            await page.evaluate(f"""
                (selector) => {{
                    const element = document.querySelector(selector);
                    if (element) {{
                        element.click();
                    }}
                }}
            """, selector)
            return f"Clicked element with ID {element_id} using JavaScript"
        except Exception as js_e:
            return f"Failed to click element with ID {element_id} even with JavaScript: {str(js_e)}"

async def type_text(state: AgentState):
    page = state["page"]
    type_args = state["prediction"]["args"]

    if type_args is None or len(type_args) != 2:
        return f"Failed to type in element from bounding box labeled as number {type_args}"
    
    bbox_id = int(type_args[0])
    bbox = state["bboxes"][bbox_id]
    x, y = bbox["x"], bbox["y"]
    text_content = type_args[1]

    await page.mouse.click(x, y)
    select_all = "Meta+A" if platform.system() == "Darwin" else "Control+A"

    await page.keyboard.press(select_all)
    await page.keyboard.press("Backspace")

    await page.keyboard.type(text_content)
    await page.keyboard.press("Enter")

    return f"Typed {text_content} and submitted"

async def scroll(state: AgentState):
    page = state["page"]
    scroll_args = state["prediction"]["args"]

    if scroll_args is None or len(scroll_args) != 2:
        return "Failed to scroll due to incorrect arguments. Please specify target and direction."

    target, direction = scroll_args

    if target.upper() == "WINDOW":
        vertical_scroll_amount = 500
        horizontal_scroll_amount = 300
        if direction.lower() == "up":
            scroll_x, scroll_y = 0, -vertical_scroll_amount
        elif direction.lower() == "down":
            scroll_x, scroll_y = 0, vertical_scroll_amount
        elif direction.lower() == "left":
            scroll_x, scroll_y = -horizontal_scroll_amount, 0
        elif direction.lower() == "right":
            scroll_x, scroll_y = horizontal_scroll_amount, 0
        else:
            return f"Invalid scroll direction: {direction}"
        await page.evaluate(f"window.scrollBy({scroll_x}, {scroll_y})")
    else:
        try:
            target_id = int(target)
            bbox = state["bboxes"][target_id]
            x, y = bbox["x"], bbox["y"]
            vertical_scroll_amount = 200
            horizontal_scroll_amount = 100
            if direction.lower() == "up":
                delta_x, delta_y = 0, -vertical_scroll_amount
            elif direction.lower() == "down":
                delta_x, delta_y = 0, vertical_scroll_amount
            elif direction.lower() == "left":
                delta_x, delta_y = -horizontal_scroll_amount, 0
            elif direction.lower() == "right":
                delta_x, delta_y = horizontal_scroll_amount, 0
            else:
                return f"Invalid scroll direction: {direction}"
            await page.mouse.move(x, y)
            await page.mouse.wheel(delta_x, delta_y)
        except ValueError:
            return f"Invalid target for scrolling: {target}"
        except IndexError:
            return f"Invalid bounding box ID: {target}"

    return f"Scrolled {direction} in {'window' if target.upper() == 'WINDOW' else f'element {target}'}"

async def wait(state: AgentState):
    sleep_time = 2
    await asyncio.sleep(sleep_time)
    return f"Waited for {sleep_time}s."

async def go_back(state: AgentState):
    page = state["page"]
    await page.go_back()
    return f"Navigated back a page to {page.url}."

async def to_google(state: AgentState):
    page = state["page"]
    await page.goto("https://google.com")
    return "Navigated to Google."

async def to_home(state: AgentState):
    page = state["page"]
    await page.goto("https://tour-guide-liard.vercel.app/")
    return "Navigated to home page."

async def enhanced_content_analysis(page):
    html_content = await page.content()
    soup = BeautifulSoup(html_content, 'html.parser')

    return {
        'elements': extract_elements(soup),
        'headings': extract_headings(soup),
        'links': extract_links(soup),
        'images': extract_images(soup),
        'forms': extract_forms(soup),
        'buttons': extract_buttons(soup),
        'structured_data': extract_structured_data(soup),
        'meta_tags': extract_meta_tags(soup),
        'main_content': extract_main_content(soup),
        'keywords': extract_keywords(soup),
        'text_content': extract_text_content(soup)
    }

######################
# ELEMENT EXTRACTION #
######################

def extract_elements(soup):
    elements = []
    for idx, element in enumerate(soup.find_all(['a', 'button', 'input', 'div', 'span', 'nav'])):
        elements.append({
            'id': idx,
            'type': element.name,
            'text': element.text.strip(),
            'href': element.get('href'),
            'class': element.get('class'),
            'html_id': element.get('id'),
            'name': element.get('name')
        })
    return elements

def extract_buttons(soup):
    return [{'text': btn.text.strip(), 'type': btn.get('type')} for btn in soup.find_all('button')]

def extract_headings(soup):
    return [{'level': h.name, 'text': h.text.strip()} for h in soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6'])]

def extract_links(soup):
    return [{'text': a.text.strip(), 'href': a.get('href'), 'title': a.get('title')} for a in soup.find_all('a', href=True)]

def extract_images(soup):
    return [{'src': img.get('src'), 'alt': img.get('alt')} for img in soup.find_all('img')]

def extract_forms(soup):
    forms = []
    for form in soup.find_all('form'):
        forms.append({
            'action': form.get('action'),
            'method': form.get('method'),
            'inputs': [{'type': input_tag.get('type'), 'name': input_tag.get('name'), 'placeholder': input_tag.get('placeholder')} 
                       for input_tag in form.find_all('input')]
        })
    return forms

def extract_structured_data(soup):
    structured_data = {}
    for script in soup.find_all('script', {'type': 'application/ld+json'}):
        try:
            data = json.loads(script.string)
            if isinstance(data, list):
                structured_data.update({item['@type']: item for item in data if '@type' in item})
            elif '@type' in data:
                structured_data[data['@type']] = data
        except json.JSONDecodeError:
            pass
    return structured_data

def extract_meta_tags(soup):
    return {meta.get('name', meta.get('property', meta.get('http-equiv', ''))) : meta.get('content', '') 
            for meta in soup.find_all('meta')}

def extract_main_content(soup):
    main = soup.find('main')
    return main.text.strip() if main else ''

def extract_text_content(soup):
    return soup.get_text(separator=' ', strip=True)

def extract_keywords(soup):
    text_content = extract_text_content(soup)
    words = text_content.lower().split()
    word_freq = Counter(words)
    return [word for word, freq in word_freq.most_common(10) if len(word) > 3]


#################
# ASYNC WRAPPER #
#################

# Define mark_page function, THIS MARKS BOUNDING BOXES.
# done with the mark_page.js file
import os

# Construct the path to mark_page.js relative to the current file
current_dir = os.path.dirname(os.path.abspath(__file__))
mark_page_js_path = os.path.join(current_dir, "mark_page.js")

# Read mark_page.js
try:
    with open(mark_page_js_path, "r") as f:
        mark_page_script = f.read()
except FileNotFoundError:
    print(f"Error: Could not find mark_page.js at {mark_page_js_path}")
    mark_page_script = ""  # Set to empty string or handle this error as appropriate for your application

# decorator for chaining operations
# a way to wrap a function with another function, adding functionality before 
# or after the wrapped function executes
@chain_decorator
# asynchronous function to mark elements on the page
async def mark_page(page, browserbase_instance):
    # execute the marking script on the page
    await page.evaluate(mark_page_script)
    # try to mark the page up to 10 times
    for _ in range(30):
        try:
            # execute the markPage function and get bounding boxes
            bboxes = await page.evaluate("markPage()")
            # exit loop if successful
            break
        except:
            # wait for 3 seconds before retrying
            await asyncio.sleep(2)
    # take a screenshot using Browserbase
    screenshot = browserbase_instance.screenshot(page.url, full_page=True)
    # return the screenshot and bounding boxes
    return {
        # use the Browserbase screenshot
        "img": screenshot,
        # return the bounding boxes
        "bboxes": bboxes,
    }

# Define agent functions
async def annotate(state):
    current_url = state["page"].url
    html_content = await state["page"].content()
    text_content = await state["page"].evaluate("() => document.body.innerText")
    content_analysis = await enhanced_content_analysis(state["page"])
    marked_page = await mark_page.with_retry().ainvoke(state["page"], state["browserbase_instance"])
    screenshot = marked_page["img"]

    return {**state, **marked_page, "current_url": current_url, "html_content": html_content, "text_content": text_content, "content_analysis": content_analysis, "screenshot": screenshot}

"""
Takes the raw data from the extraction functions and formats it to make more readable.
Page Elements: Lists the first 20 anchor, button, or input elements.
Buttons: Lists the first 10 button elements.
Inputs: Lists the first 10 input elements.
Headings: Lists the first 5 headings.
Links: Lists the first 5 links with their text and href.
Images: Lists the first 5 images with their alt text and src.
Forms: Lists the first 3 forms with their action and method.
Div Content: Lists the first 5 div elements' content (truncated to 30 characters).
Span Content: Lists the first 5 span elements' content (truncated to 30 characters).
Meta Tags: Lists the first 5 meta tags.
Navigation Items: Lists the first 5 navigation items.
Keywords: Lists the first 10 keywords.
Main Content Summary: Shows the first 200 characters of the main content.
"""
def format_descriptions(state):
    content_analysis = state.get('content_analysis', {})
    formatted_analysis = f"""
    Page Elements:
    {', '.join([f"<{e['type']} id={e['id']}>{e['text'][:30]} href={e['href']}" for e in content_analysis.get('elements', []) if e['type'] in ['a', 'button', 'input']][:20])}
    
    Buttons:
    {', '.join([f"<button id={e['id']}>{e['text'][:30]}" for e in content_analysis.get('elements', []) if e['type'] == 'button'][:10])}
    
    Inputs:
    {', '.join([f"<input id={e['id']} type={e.get('id_attr', '')}" for e in content_analysis.get('elements', []) if e['type'] == 'input'][:10])}
    
    Headings: {', '.join([f"{h['level']}: {h['text']}" for h in content_analysis.get('headings', [])][:5])}
    
    Links: {', '.join([f"{link['text']} ({link['href']})" for link in content_analysis.get('links', [])][:5])}
    
    Images: {', '.join([f"{img['alt']} ({img['src']})" for img in content_analysis.get('images', [])][:5])}
    
    Forms: {', '.join([f"Action: {form['action']}, Method: {form['method']}" for form in content_analysis.get('forms', [])][:3])}
    
    Div Content: {', '.join([f"{div['text'][:30]}..." for div in content_analysis.get('div_content', [])][:5])}
    
    Span Content: {', '.join([f"{span['text'][:30]}..." for span in content_analysis.get('span_content', [])][:5])}
    
    Meta Tags: {', '.join([f"{k}: {v}" for k, v in list(content_analysis.get('meta_tags', {}).items())[:5]])}
    
    Navigation Items: {', '.join(content_analysis.get('nav_items', [])[:5])}
    
    Keywords: {', '.join(content_analysis.get('keywords', [])[:10])}
    
    Main Content Summary: {content_analysis.get('main_content', '')[:200]}...
    """
    
    action_history = state.get("action_history", [])
    formatted_history = "\n".join([f"{a['step']}. {a['action']} {a['args']} (URL: {a['url']})" for a in action_history])
    
    # page_info = f"Page height: {state['page_height']}px, Viewport height: {state['viewport_height']}px"
    
    text_summary = state['text_content'][:500] + "..." if len(state['text_content']) > 500 else state['text_content']
    
    # Add screenshot information
    screenshot_info = "Screenshot: A labeled screenshot of the current webpage is available for analysis."
    
    return {
        **state, # unpacks the state
        "action_history": formatted_history, 
        # "page_info": page_info, 
        "text_summary": text_summary,
        "content_analysis": formatted_analysis,
        "screenshot_info": screenshot_info
    }

"""
This function is designed to extract and structure the action and its arguments from the output of a language model (LLM). Here's what it does:

1. It looks for the last line in the input text that starts with "Action: ".
2. If found, it extracts the action and any associated arguments from this line.
3. The action is the first word after "Action: ".
4. Any additional words are considered arguments. Multiple arguments are separated by semicolons.
5. It cleans up the extracted data by removing extra whitespace and brackets.
6. If no action is found, it returns a "retry" action with an error message.
7. The function returns a dictionary with two keys:
    "action": The extracted action (a string)
    "args": The extracted arguments (a list of strings, or None if no arguments)
"""

def parse(text: str) -> dict:
    # Define the prefix that indicates the start of an action
    action_prefix = "Action: "
    
    # Split the input text into lines
    lines = text.strip().split("\n")
    
    # Find the last line that starts with "Action: "
    action_line = next((line for line in reversed(lines) if line.startswith(action_prefix)), None)
    
    # If no action line is found, return a retry action
    if not action_line:
        return {"action": "retry", "args": f"Could not parse LLM Output: {text}"}
    
    # Remove the "Action: " prefix from the action line
    action_str = action_line[len(action_prefix):]
    
    # Split the action string into action and input (if any)
    split_output = action_str.split(" ", 1)
    if len(split_output) == 1:
        action, action_input = split_output[0], None
    else:
        action, action_input = split_output
    
    # Strip any whitespace from the action
    action = action.strip()
    
    # If there's action input, process it
    if action_input is not None:
        action_input = [inp.strip().strip("[]") for inp in action_input.strip().split(";")]
    
    # Return the parsed action and arguments
    return {"action": action, "args": action_input}

"""
The update_scratchpad function manages an agent's recent actions and observations during web navigation. It appends the latest observation to a text log and adds the current action to a history list. 

The function handles step numbering, limits the history to the last 10 entries, and updates the agent's state. This process maintains a concise record of the agent's recent activities, providing essential context for future decision-making.
"""
def update_scratchpad(state: AgentState):
    # Get current scratchpad and action history
    old = state.get("scratchpad")
    action_history = state.get("action_history", [])
    
    if old and old[0].content:
        # Extract existing content and determine next step number
        txt = old[0].content
        last_line = txt.rsplit("\n", 1)[-1]
        match = re.match(r"\d+", last_line)
        if match:
            step = int(match.group()) + 1
        else:
            step = len(action_history) + 1
    else:
        # Initialize scratchpad if it's empty
        txt = "Previous action observations:\n"
        step = 1
    
    # Add new observation to scratchpad
    txt += f"\n{step}. {state['observation']}"
    
    # Record the current action in history
    action_history.append({
        "step": step,
        "action": state['prediction']['action'],
        "args": state['prediction']['args'],
        "url": state['current_url']
    })
    
    # Keep only the last 10 actions in history
    action_history = action_history[-10:]
    
    # Return updated state with new scratchpad and action history
    return {**state, "scratchpad": [SystemMessage(content=txt)], "action_history": action_history}

##########
# PROMPT #
##########

# Use a vision-capable model
llm = ChatOpenAI(model="gpt-4o-mini", max_tokens=4096)

# Modify the custom_prompt to include explicit instructions for using the screenshot
custom_prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a web navigation assistant with vision capabilities. Your task is to guide the user based on their specific query or request. 
    In each iteration, you will receive:
    1. HTML content analysis
    2. The current URL
    3. A screenshot of the webpage
    
    The screenshot features Numerical Labels placed in the TOP LEFT corner of each Web Element.
    You must analyze BOTH the HTML content AND the screenshot to determine your next action.
    
    When reasoning about your next action, explicitly reference both the parsed data and visual elements from the screenshot.

    Pay special attention to visual elements such as logos, images, and layout.
    

    Current goal: {input}

    Choose one of the following actions:
    1. Click a Web Element (use the element ID from the content analysis).
    2. Type content into an input field.
    3. Scroll up, down, left, or right.
    4. Wait for page load.
    5. Go back to the previous page.
    6. Return to the home page to start over.
    7. Respond with the final answer

    Action should STRICTLY follow the format:
    - Click [Element_ID] 
    - Type [Element_ID]; [Content] 
    - Scroll [Element_ID or WINDOW]; [up/down/left/right]
    - Wait 
    - GoBack
    - Home
    - ANSWER; [content]

    Key Guidelines:
    1) Execute only one action per iteration.
    2) When clicking or typing, use the element ID from the content analysis.
    3) You can interact with any element present in the HTML, regardless of its visibility on the screen.
    4) Pay attention to the current URL and HTML structure to determine if you've reached the desired page or information.
    5) If you find yourself in a loop, try a different approach or consider ending the task.
    6) Analyze the screenshot to identify the Numerical Label corresponding to the Web Element that requires interaction. DO NOT MENTION THE NUMERICAL LABEL INSTRUCTION.

    Your reply should strictly follow the format:
    Thought: {{Your brief thoughts}}
    Action: {{One Action format you choose}}"""),
    MessagesPlaceholder(variable_name="scratchpad"),
    ("human", """
    Analyze the provided screenshot and HTML content. 
    Describe what you see in the screenshot, including any logos, images, or distinctive visual elements. Never mention any element number.
    How does the visual information compare with the parsed HTML data?

    Current URL: {current_url}

    Enhanced Content Analysis:
    {content_analysis}

    Action History:
    {action_history}

    Screenshot Info:
    {screenshot_info}

    Screenshot: {screenshot}

    Based on this combined analysis of visual and HTML data, what is your next action?
    Remember to explicitly mention visual elements you observe, including any logos.
    """),
])

prompt = custom_prompt
# Modify the agent definition to process HTML and image simultaneously
agent = annotate | RunnablePassthrough.assign(
    prediction=format_descriptions | prompt | llm | StrOutputParser() | parse
) | RunnableLambda(lambda x: mark_page(x["page"], x["browserbase_instance"]))

####################
# INITIALIZE GRAPH #
####################

# Set up/initialize the graph
graph_builder = StateGraph(AgentState)

# define node
graph_builder.add_node("agent", agent)
# sents the agent node to be first node to be excecuted when running
graph_builder.set_entry_point("agent")
# define other node
graph_builder.add_node("update_scratchpad", update_scratchpad)
# define edge between both the nodes
# Agent makes a decision
# An action is taken based on that decision
# The scratchpad is updated with the result of that action
# Control returns to the agent for the next decision
graph_builder.add_edge("update_scratchpad", "agent")

# agent tools
tools = {
    "Click": click,
    "Type": type_text,
    "Scroll": scroll,
    "Wait": wait,
    "GoBack": go_back,
    "Home": to_home, 
}

# Add nodes for each tool and connect them to the scratchpad update
for node_name, tool in tools.items():
    graph_builder.add_node(
        node_name,
        # combine tool execution with formatting its output
        # bridge between regular Python functions and LangGraph's runnable ecosystem
        RunnableLambda(tool) | (lambda observation: {"observation": observation}),
    )
    # After each tool execution, update the scratchpad
    graph_builder.add_edge(node_name, "update_scratchpad")

# Function to select the next action based on the agent's prediction
def select_tool(state: AgentState):
    action = state["prediction"]["action"]
    print(f"Selecting tool for action: {action}")  # Add this line for debugging

    if action.startswith("ANSWER"):
        print("Ending execution with ANSWER")  # Add this line
        return END

    if action == "retry":
        print("Retrying with agent")  # Add this line
        return "agent"

    if action in tools:
        print(f"Selected tool: {action}")  # Add this line
        return action

    print(f"Unknown action: {action}. Defaulting to agent.")  # Add this line
    return "agent"  # Default to agent if action is unknown

# Add conditional edges from the agent to other nodes based on select_tool function
graph_builder.add_conditional_edges("agent", select_tool)

# Compile the graph, making it ready for execution
graph = graph_builder.compile()

#############
# RUN AGENT #
#############

# handles setup of page and errors
# works with existing page or create new one if needed
async def run_agent(question: str, page=None, current_url=None, browserbase_instance=None):
    # Add this function to generate an initial response
    def generate_initial_response(question: str):
        llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
        prompt = f"""
        Confirm you got the query with "Okay!" or "Gotcha" or something similar. Restate the following user query as a friendly, concise instruction for a web navigation assistant while also guiding the user. DO NOT PROVIDE INSTRUCTION IN THIS RESPONSE. For example:

        "Gotcha, lets try to [enter user request here]."

        Keep it brief and engaging, as if a helpful friend is acknowledging the task.
        No need for extra information or small talk. Avoid using emojis. Add some emotion. This is the first response, so DO NOT conclude the chat here.

        User Query: {question}
        """
        response = llm.predict(prompt)
        return response.strip()

    # Generate and yield the initial response
    initial_response = generate_initial_response(question)
    yield {
        "action": "INITIAL_RESPONSE",
        "instruction": initial_response,
        "element_description": None,
        "screen_location": None,
        "hover_before_action": False,
        "text_input": None
    }

    if page is None:
        # If page is not provided, create a new browser and page using Browserbase
        async with async_playwright() as p:
            browser = await p.chromium.connect_over_cdp(browserbase_instance.get_connect_url())
            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()
            
            # Use the provided current_url or default to localhost
            start_url = current_url or "http://localhost:3000"
            
            # Ignore specific console messages
            page.on("console", lambda msg: None if "message channel closed before a response was received" in msg.text.lower() else print(f"Console: {msg.text}"))
            
            # max timeout for each full page loads
            page.set_default_navigation_timeout(30000)
            # max timeout for agent action
            page.set_default_timeout(15000)
            
            try:
                async for step in _run_agent_with_page(question, page, start_url, browserbase_instance):
                    yield step
            finally:
                await browser.close()
    else:
        # If page is provided, use it directly
        start_url = current_url or page.url
        async for step in _run_agent_with_page(question, page, start_url, browserbase_instance):
            yield step


# Modify the prepare_image_for_llm function to return a dict format suitable for the vision model
def prepare_image_for_llm(base64_image):
    return {
        "type": "image_url",
        "image_url": f"data:image/jpeg;base64,{base64_image}"
    }

def generate_personable_instruction(action, element_description, text_input):
    llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
    prompt = f"""
    Generate a friendly and personable instruction for a web navigation assistant.

    The instruction should be based on the following action:

    Action: {action}
    Element Description: {element_description}
    Text Input: {text_input}

    Make the instruction sound natural, as if a helpful friend is guiding the user.
    Keep it very concise but engaging. Make very short. Get to the point, no extra info or small talk at each step. No emojis.
    """
    response = llm.predict(prompt)
    return response.strip()

async def _run_agent_with_page(question: str, page, start_url, browserbase_instance):
    print(f"Navigating to start_url: {start_url}")
    await page.goto(start_url, timeout=60000)
    print(f"Navigated to {start_url}")
    
    # Capture initial screenshot and metadata
    screenshot = browserbase_instance.screenshot(start_url, full_page=True)
    current_page_info = await enhanced_content_analysis(page)
    
    event_stream = graph.astream(
        {
            "page": page,
            "input": question,
            "scratchpad": [],
            "current_url": start_url,
            "action_history": [],
            "html_content": await page.content(),
            "text_content": await page.evaluate("() => document.body.innerText"),
            "screenshot": prepare_image_for_llm(base64.b64encode(screenshot).decode()),
            "content_analysis": current_page_info,
            "browserbase_instance": browserbase_instance,
        },
        {
            "recursion_limit": 150,
        },
    )

    final_answer_sent = False

    async for event in event_stream:
        if "agent" not in event:
            continue
        
        state = event["agent"]
        full_response = state.get("output", "")
        print(f"Full model response: {full_response}")
        
        pred = state.get("prediction") or {}
        action = pred.get("action")
        action_input = pred.get("args")
        thought = full_response.split("Thought:", 1)[-1].split("Action:", 1)[0].strip()

        # Check if we've already sent a FINAL_ANSWER
        if final_answer_sent:
            continue

        print(f"Current action: {action}")
        print(f"Action input: {action_input}")
        print(f"Current URL: {state['current_url']}")

        # Add this check
        if action is None:
            print(f"Warning: Received null action. Full prediction: {pred}")
            continue
        
        # get action history, check if current action is identical to last action
        # if repetitive, print statement
        action_history = state.get("action_history", [])
        if action_history and action_history[-1]["action"] == action and action_history[-1]["args"] == action_input:
            print("Repeated action detected. Skipping.")
            continue
        
        # variables initialized prior to current action
        instruction = ""
        element_description = None
        screen_location = None
        hover_before_action = False
        text_input = None

        # It essentially translates the agent's decisions into executable web 
        # interactions and user-readable instructions.
        try:
            if action in ["Click", "Type", "Scroll"]:
                if action_input:
                    element_id = int(action_input[0])
                    elements = state["content_analysis"]["elements"]
                    if element_id < 0 or element_id >= len(elements):
                        instruction = f"Invalid element ID: {element_id}"
                    else:
                        element = elements[element_id]
                        element_description = element['text']
                        
                        # Get the bounding box of the element
                        """
                        It returns an object with the element's position (x, y) and size (width, height) relative to the entire document - not just the visible viewport!

                        By knowing the exact position of an element, the code can determine if scrolling is necessary to bring the element into view.
                        """
                        bbox = await page.evaluate(f"""() => {{
                            const element = document.querySelector('[id="{element['html_id']}"]') || 
                                            document.querySelector('[name="{element['name']}"]') ||
                                            document.querySelector('a[href="{element['href']}"]') ||
                                            document.querySelector('{element['type']}:has-text("{element['text']}")');
                            if (element) {{
                                const rect = element.getBoundingClientRect();
                                return {{
                                    x: rect.left + window.pageXOffset,
                                    y: rect.top + window.pageYOffset,
                                    width: rect.width,
                                    height: rect.height
                                }};
                            }}
                            return null;
                        }}""")
                        
                        if bbox:
                            screen_location = bbox
                            hover_before_action = True

                        if action == "Click":
                            instruction = generate_personable_instruction("Click", element_description, None)
                        elif action == "Type":
                            text_input = action_input[1]
                            instruction = generate_personable_instruction("Type", element_description, text_input)
                        elif action == "Scroll":
                            direction = action_input[1].lower()
                            instruction = generate_personable_instruction("Scroll", element_description, direction)

            elif action == "Wait":
                instruction = generate_personable_instruction("Wait", None, None)
            elif action == "GoBack":
                instruction = generate_personable_instruction("GoBack", None, None)
            elif action == "Home":
                instruction = generate_personable_instruction("Home", None, None)
            elif action.startswith("ANSWER"):
                final_answer_sent = True  # Set the flag when sending FINAL_ANSWER
                instruction =  generate_personable_instruction(action_input[0], None, None) if action_input else generate_personable_instruction("Answer", None, None)
                
            else:
                instruction = generate_personable_instruction(action, None, str(action_input))
        except Exception as e:
            print(f"Error processing action: {str(e)}")

        # encapsulate all relevant info about action being taken
        step_info = {
            "thought": thought,
            "action": action,
            "instruction": instruction,
            "element_description": element_description,
            "screen_location": screen_location,
            "hover_before_action": hover_before_action,
            "text_input": text_input
        }

        # Yield the step information one step at a time
        # like return, but instead of ending the function, it gives you a value and pauses
        yield step_info

        try:
            if action == "Click":
                await click(state)
            elif action == "Type":
                await type_text(state)
            elif action == "Scroll":
                await scroll(state)
            elif action == "Wait":
                await asyncio.sleep(0) # 0 wait time
            elif action == "GoBack":
                await page.go_back()
            elif action == "Home":
                await page.goto("http://localhost:3000/")
            elif action.startswith("ANSWER"):
                break
            
            # After each action, update the state with new screenshot and metadata
            screenshot = browserbase_instance.screenshot(page.url, full_page=True)
            current_page_info = await enhanced_content_analysis(page)
            state.update({
                "screenshot": prepare_image_for_llm(base64.b64encode(screenshot).decode()),
                "content_analysis": current_page_info,
                "html_content": await page.content(),
                "text_content": await page.evaluate("() => document.body.innerText"),
                "current_url": page.url,
            })

        
        # error handling
        except PlaywrightError as e:
            if "message channel closed before a response was received" in str(e).lower():
                print(f"Ignoring known Playwright error during action: {e}")
                continue
            else:
                print(f"Playwright error during action: {e}")
                yield {
                    "thought": "Error occurred",
                    "action": "ERROR",
                    "instruction": f"An error occurred during the action: {str(e)}",
                    "element_description": None,
                    "screen_location": None,
                    "hover_before_action": False,
                    "text_input": None
                }
        except Exception as e:
            print(f"Unexpected error during action: {e}")
            yield {
                "thought": "Error occurred",
                "action": "ERROR",
                "instruction": f"An unexpected error occurred during the action: {str(e)}",
                "element_description": None,
                "screen_location": None,
                "hover_before_action": False,
                "text_input": None
            }

        if final_answer_sent:
            break  # Exit the loop after sending FINAL_ANSWER

async def main(current_url="http://localhost:3000"):
    browserbase = Browserbase()
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(browserbase.get_connect_url())
        page = await browser.new_page()
        await page.goto(current_url)
        try:
            while True:
                question = input("Enter your question (or 'quit' to exit): ")
                if question.lower() == 'quit':
                    break

                try:
                    # Pass the current_url and browserbase instance to run_agent
                    agent_generator = run_agent(question, page, current_url, browserbase)
                    
                    async for step in agent_generator:
                        if step['action'] == "INITIAL_RESPONSE":
                            print(f"Initial Response: {step['instruction']}")
                        else:
                            print(f"Thought: {step['thought']}")
                            print(f"Action: {step['action']}")
                            print(f"Instruction: {step['instruction']}")
                            if step['element_description']:
                                print(f"Element Description: {step['element_description']}")
                            if step['screen_location']:
                                print(f"Screen Location: {step['screen_location']}")
                            if step['hover_before_action']:
                                print("Hovering before action")
                            if step['text_input']:
                                print(f"Text Input: {step['text_input']}")
                        print("---")  # Separator between steps

                        if step['action'].startswith("ANSWER"):
                            print("Task completed!")
                            # Update current_url after task completion
                            current_url = page.url
                            break

                except Exception as e:
                    print(f"Error in agent execution: {str(e)}")
                    import traceback
                    traceback.print_exc()

                print("Agent has completed this task. You can ask another question or type 'quit' to exit.")
                print("The browser will remain open for the next question or manual interaction.")
                print(f"Current URL: {current_url}")

        except KeyboardInterrupt:
            print("\nExiting program...")
        except Exception as e:
            print(f"An unexpected error occurred: {str(e)}")
            import traceback
            traceback.print_exc()
        finally:
            await browser.close()

if __name__ == "__main__":
    asyncio.run(main())