# -*- coding: utf-8 -*-
"""web_voyager.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/albeorla/google-collab-notebooks/blob/main/web_voyager.ipynb

WHY IT DOESN'T WORK:
- inaccurate
- loops non-stop, keeps repeating same mistake
- 
"""

import os
import asyncio
import base64
import platform
import re
from typing import List, Optional, TypedDict
from dotenv import load_dotenv

from langchain_core.messages import BaseMessage, SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnablePassthrough, RunnableLambda, chain as chain_decorator
from langchain_openai import ChatOpenAI
from langchain import hub
from langgraph.graph import END, StateGraph
from playwright.async_api import Page, async_playwright

# Load environment variables
load_dotenv()

# Set up environment variables
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_PROJECT"] = "Web-Voyager"
os.environ["LANGCHAIN_API_KEY"] = os.getenv("LANGCHAIN_API_KEY")
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

# Define types
class BBox(TypedDict):
    x: float
    y: float
    text: str
    type: str
    ariaLabel: str

class Prediction(TypedDict):
    action: str # 
    args: Optional[List[str]]

class AgentState(TypedDict):
    page: Page # single page in browser, provides ways to interact with web pages
    input: str
    img: str
    bboxes: List[BBox]  # list of bounding boxes
    prediction: Prediction # another class defined above
    scratchpad: List[BaseMessage] # acts as the memory for the agent
    observation: str

###############
# AGENT TOOLS #
###############

# Define tools
async def click(state: AgentState):
    page = state["page"]
    click_args = state["prediction"]["args"]
    if click_args is None or len(click_args) != 1:
        mouse_position = await page.evaluate("({x: window.mouseX, y: window.mouseY})")
        return f"Failed to click bounding box", mouse_position['x'], mouse_position['y']
    
    bbox_id_or_label = click_args[0]
    bboxes = state.get("bboxes", [])
    
    # Try to find the bbox by numerical index or by matching the label
    bbox = None
    try:
        bbox_id = int(bbox_id_or_label)
        if 0 <= bbox_id < len(bboxes):
            bbox = bboxes[bbox_id]
    except ValueError:
        # If conversion to int fails, search for a bbox with matching label
        for i, box in enumerate(bboxes):
            if box.get("ariaLabel") == bbox_id_or_label or box.get("text") == bbox_id_or_label:
                bbox = box
                break
    
    if bbox is None:
        mouse_position = await page.evaluate("({x: window.mouseX, y: window.mouseY})")
        return f"Error: no bbox found for: {bbox_id_or_label}", mouse_position['x'], mouse_position['y']
    
    x, y = bbox["x"], bbox["y"]
    await page.mouse.click(x, y)
    return f"Clicked {bbox_id_or_label}", x, y

async def type_text(state: AgentState):
    # Get the page object from the state
    page = state["page"]
    # Get the typing arguments from the state
    type_args = state["prediction"]["args"]
    # Check if the arguments are valid
    if type_args is None or len(type_args) != 2:
        return f"Failed to type in element from bounding box labeled as number {type_args}"
    # Get the bounding box ID
    bbox_id = int(type_args[0])
    # Get the bounding box information
    bbox = state["bboxes"][bbox_id]
    # Extract x and y coordinates from the bounding box
    x, y = bbox["x"], bbox["y"]
    # Get the text to be typed
    text_content = type_args[1]
    # Click on the element at the specified coordinates
    await page.mouse.click(x, y)
    # Determine the "Select All" keyboard shortcut based on the operating system
    select_all = "Meta+A" if platform.system() == "Darwin" else "Control+A"
    # Select all existing text in the element
    await page.keyboard.press(select_all)
    # Delete the selected text
    await page.keyboard.press("Backspace")
    # Type the new text content
    await page.keyboard.type(text_content)
    # Press Enter to submit the input
    await page.keyboard.press("Enter")
    # Return a success message
    return f"Typed {text_content} and submitted", x, y


async def scroll(state: AgentState):
    page = state["page"]
    scroll_args = state["prediction"]["args"]
    if scroll_args is None or len(scroll_args) != 2:
        return "Failed to scroll due to incorrect arguments."

    # unpack scroll arguments into target and direction
    target, direction = scroll_args

    # set scroll amount
    scroll_amount = 500

    # determine scroll direction and axis
    if direction.lower() == "up":
        scroll_x, scroll_y = 0, -scroll_amount
    elif direction.lower() == "down":
        scroll_x, scroll_y = 0, scroll_amount
    elif direction.lower() == "left":
        scroll_x, scroll_y = -scroll_amount, 0
    elif direction.lower() == "right":
        scroll_x, scroll_y = scroll_amount, 0
    else:
        return "Invalid scroll direction."

    if target.upper() == "WINDOW":
        # execute javascript to scroll the window
        await page.evaluate(f"window.scrollBy({scroll_x}, {scroll_y})")
        # Get the viewport size
        viewport_size = await page.evaluate("({width: window.innerWidth, height: window.innerHeight})")
        return f"Scrolled {direction} in window", viewport_size['width'] / 2, viewport_size['height'] / 2
    else:
        # convert target to integer for bounding box lookup
        target_id = int(target)
        # get bounding box for the target element
        bbox = state["bboxes"][target_id]
        # extract x and y coordinates from bounding box
        x, y = bbox["x"], bbox["y"]
        # move mouse to the target element
        await page.mouse.move(x, y)
        # perform scroll action on the element
        await page.mouse.wheel(scroll_x, scroll_y)
        return f"Scrolled {direction} in element", x, y

async def wait(state: AgentState):
    sleep_time = 5
    # asyncio allows other funcs to continue while waiting
    await asyncio.sleep(sleep_time)
    # Get the current mouse position
    mouse_position = await state["page"].evaluate("({x: window.mouseX, y: window.mouseY})")
    return f"Waited for {sleep_time}s", mouse_position['x'], mouse_position['y']

async def go_back(state: AgentState):
    page = state["page"]
    # playwright function
    await page.go_back()
    # Get the dimensions of the viewport
    viewport_size = page.viewport_size
    return f"Navigated back a page to {page.url}", viewport_size['width'] / 2, viewport_size['height'] / 2

async def to_google(state: AgentState):
    page = state["page"]
    await page.goto("https://www.google.com/")
    # Get the dimensions of the viewport
    viewport_size = page.viewport_size
    return "Navigated to google.com", viewport_size['width'] / 2, viewport_size['height'] / 2

# Define mark_page function, THIS MARKS BOUNDING BOXES.
# done with the mark_page.js file
import os

# Construct the path to mark_page.js relative to the current file
current_dir = os.path.dirname(os.path.abspath(__file__))
mark_page_js_path = os.path.join(current_dir, "mark_page.js")

# Read mark_page.js
try:
    with open(mark_page_js_path, "r") as f:
        mark_page_script = f.read()
except FileNotFoundError:
    print(f"Error: Could not find mark_page.js at {mark_page_js_path}")
    mark_page_script = ""  # Set to empty string or handle this error as appropriate for your application

# decorator for chaining operations
# a way to wrap a function with another function, adding functionality before 
# or after the wrapped function executes
@chain_decorator
# asynchronous function to mark elements on the page
async def mark_page(page):
    # execute the marking script on the page
    await page.evaluate(mark_page_script)
    # try to mark the page up to 10 times
    for _ in range(10):
        try:
            # execute the markPage function and get bounding boxes
            bboxes = await page.evaluate("markPage()")
            # exit loop if successful
            break
        except:
            # wait for 3 seconds before retrying
            await asyncio.sleep(2)
    # take a screenshot of the marked page
    screenshot = await page.screenshot()
    # # remove the markings from the page
    # await page.evaluate("unmarkPage()")
    # return the screenshot and bounding boxes
    return {
        # encode the screenshot as base64
        "img": base64.b64encode(screenshot).decode(),
        # return the bounding boxes
        "bboxes": bboxes,
    }


# Define agent functions
async def annotate(state):
    marked_page = await mark_page.with_retry().ainvoke(state["page"])
    # Don't unmark the page here
    return {**state, **marked_page}


# define function that takes a state parameter
def format_descriptions(state):
    # initialize an empty list to store formatted labels
    labels = []
    # iterate over bounding boxes in state, with index
    for i, bbox in enumerate(state["bboxes"]):
        # get ariaLabel if it exists, otherwise empty string
        text = bbox.get("ariaLabel") or ""
        # if text is empty or only whitespace, use bbox text instead
        if not text.strip():
            text = bbox["text"]
        # get the type of the element
        el_type = bbox.get("type")
        # append formatted string to labels list
        labels.append(f'{i} (<{el_type}/>): "{text}"')
    # create a string of all labels, joined by newlines
    bbox_descriptions = "\nValid Bounding Boxes:\n" + "\n".join(labels)
    # return updated state with new bbox_descriptions
    return {**state, "bbox_descriptions": bbox_descriptions}


def parse(text: str) -> dict:
    action_prefix = "Action: "
    if not text.strip().split("\n")[-1].startswith(action_prefix):
        return {"action": "retry", "args": f"Could not parse LLM Output: {text}"}
    action_block = text.strip().split("\n")[-1]

    action_str = action_block[len(action_prefix):]
    split_output = action_str.split(" ", 1)
    if len(split_output) == 1:
        action, action_input = split_output[0], None
    else:
        action, action_input = split_output
    action = action.strip()
    if action_input is not None:
        action_input = [inp.strip().strip("[]") for inp in action_input.strip().split(";")]
    return {"action": action, "args": action_input}


"""
crucial for maintaining the agent's "memory" and providing it with a structured history of its interactions. This history is vital for the agent to perform complex, multi-step tasks on web pages, as it allows the agent to reference past actions, understand the current context, and make more informed decisions about what to do next.
"""

def update_scratchpad(state: AgentState):
    # Get the existing scratchpad from the state, if any
    old = state.get("scratchpad")
    
    if old:
        # If there's an existing scratchpad, get its content
        txt = old[0].content
        # Extract the last line of the existing content
        last_line = txt.rsplit("\n", 1)[-1]
        # Extract the step number from the last line and increment it
        step = int(re.match(r"\d+", last_line).group()) + 1
    else:
        # If there's no existing scratchpad, initialize with a header
        txt = "Previous action observations:\n"
        # Start with step 1
        step = 1
    
    # Add the new observation to the text, with the current step number
    txt += f"\n{step}. {state['observation']}"

    # Return updated state with new scratchpad content
    # The scratchpad is a list containing a single SystemMessage
    return {**state, "scratchpad": [SystemMessage(content=txt)]}

# Set up the agent
prompt = hub.pull("wfh/web-voyager")
llm = ChatOpenAI(model="gpt-4o-mini", max_tokens=4096)
agent = annotate | RunnablePassthrough.assign(
    # | is used to chain operations together in order
    # StrOutputParser() parses into string, parse processes stirng output into structured format.
    prediction=format_descriptions | prompt | llm | StrOutputParser() | parse
)

####################
# INITIALIZE GRAPH #
####################

# Set up/initialize the graph, pass in the agent state
graph_builder = StateGraph(AgentState)
# define node
graph_builder.add_node("agent", agent)
# sents the agent node to be first node to be excecuted when running
graph_builder.set_entry_point("agent")
# define other node
graph_builder.add_node("update_scratchpad", update_scratchpad)
# define edge between both the nodes
# Agent makes a decision
# An action is taken based on that decision
# The scratchpad is updated with the result of that action
# Control returns to the agent for the next decision
graph_builder.add_edge("update_scratchpad", "agent")

# agent tools
tools = {
    "Click": click,
    "Type": type_text,
    "Scroll": scroll,
    "Wait": wait,
    "GoBack": go_back,
    "Google": to_google,
}

# Add nodes for each tool and connect them to the scratchpad update
for node_name, tool in tools.items():
    graph_builder.add_node(
        node_name,
        # Combine tool execution with formatting its output
        RunnableLambda(tool) | (lambda observation: {"observation": observation}),
    )
    # After each tool execution, update the scratchpad
    graph_builder.add_edge(node_name, "update_scratchpad")

# Function to select the next action based on the agent's prediction
def select_tool(state: AgentState):
    action = state["prediction"]["action"]
    if action == "ANSWER":
        return END  # End the process if the action is to answer
    if action == "retry":
        return "agent"  # Go back to the agent if a retry is needed
    return action  # Otherwise, return the action name (corresponding to a tool)

# Add conditional edges from the agent to other nodes based on select_tool function
graph_builder.add_conditional_edges("agent", select_tool)

# Compile the graph, making it ready for execution
graph = graph_builder.compile()

#############
# RUN AGENT #
#############

# Main function to run the agent
async def run_agent():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        page = await browser.new_page()
        await page.goto("https://google.com")

        async def call_agent(question: str, page, max_steps: int = 150):
            event_stream = graph.astream(
                {
                    "page": page,
                    "input": question,
                    "scratchpad": [],
                },
                {
                    "recursion_limit": max_steps,
                },
            )
            final_answer = None
            actions_with_coordinates = []
            async for event in event_stream:
                if "agent" not in event:
                    continue
                pred = event["agent"].get("prediction") or {}
                action = pred.get("action")
                action_input = pred.get("args")
                
                x, y = None, None
                if action in tools:
                    observation, x, y = await tools[action](event["agent"])
                else:
                    # For actions not in tools (like ANSWER), use current mouse position
                    mouse_position = await page.evaluate("({x: window.mouseX, y: window.mouseY})")
                    x, y = mouse_position['x'], mouse_position['y']
                    observation = f"{action}: {action_input}"
                
                actions_with_coordinates.append({"action": action, "args": action_input, "x": x, "y": y})
                
                print(f"{action}: {action_input} at (x: {x}, y: {y})")
                if "ANSWER" in action:
                    final_answer = action_input[0]
                    break
            return final_answer, actions_with_coordinates

        questions = [
            # "Could you explain the WebVoyager paper (on arxiv)?",
            # "Please explain the today's XKCD comic for me. Why is it funny?",
            # "What are the latest blog posts from langchain?",
            # "Look for the 10th result of the word fish on google.",
            "Go to the Decagon AI's most recent blog."

            # "Could you check google maps to see when i should leave to get to SFO by 7 o'clock? starting from SF downtown.",
        ]

        for question in questions:
            res, actions = await call_agent(question, page)
            print(f"Question: {question}")
            print(f"Final response: {res}")
            print("Actions with coordinates:")
            for action in actions:
                print(f"  {action['action']}: {action['args']} at (x: {action['x']}, y: {action['y']})")
            print()

        await browser.close()

# Run the agent
if __name__ == "__main__":
    asyncio.run(run_agent())