# -*- coding: utf-8 -*-
"""web_voyager.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/albeorla/google-collab-notebooks/blob/main/web_voyager.ipynb
"""

import os
import asyncio
import base64
import platform
import re
from typing import List, Optional, TypedDict
from dotenv import load_dotenv

from langchain_core.messages import BaseMessage, SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnablePassthrough, RunnableLambda, chain as chain_decorator
from langchain_openai import ChatOpenAI
from langchain import hub
from langgraph.graph import END, StateGraph
from playwright.async_api import Page, async_playwright

# Load environment variables
load_dotenv()

# Set up environment variables
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_PROJECT"] = "Web-Voyager"
os.environ["LANGCHAIN_API_KEY"] = os.getenv("LANGCHAIN_API_KEY")
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

# Define types
class BBox(TypedDict):
    x: float
    y: float
    text: str
    type: str
    ariaLabel: str

class Prediction(TypedDict):
    action: str # 
    args: Optional[List[str]]

class AgentState(TypedDict):
    page: Page # single page in browser, provides ways to interact with web pages
    input: str
    img: str
    bboxes: List[BBox]  # list of bounding boxes
    prediction: Prediction # another class defined above
    scratchpad: List[BaseMessage] # acts as the memory for the agent
    observation: str

###############
# AGENT TOOLS #
###############

# Define tools
async def click(state: AgentState):
    page = state["page"] # grab the page in browser
    # grab the action string list, args determined by agent b4 called
    click_args = state["prediction"]["args"]
    # if click_args above doesn't exist, click_args is expected to have one argument
    if click_args is None or len(click_args) != 1:
        return f"Failed to click bounding box labeled as number {click_args}"
    # accesses first element in click_args list, converts to int. alr decided what to click
    bbox_id = int(click_args[0])
    # access specific bounding box information
    try:
        bbox = state["bboxes"][bbox_id]
    except:
        return f"Error: no bbox for : {bbox_id}"
    # grab x and y coordinates
    x, y = bbox["x"], bbox["y"]
    # page.mouse.click() from playwrite object
    await page.mouse.click(x, y)
    return f"Clicked {bbox_id}" # returns a string

async def type_text(state: AgentState):
    # Get the page object from the state
    page = state["page"]
    # Get the typing arguments from the state
    type_args = state["prediction"]["args"]
    # Check if the arguments are valid
    if type_args is None or len(type_args) != 2:
        return f"Failed to type in element from bounding box labeled as number {type_args}"
    # Get the bounding box ID
    bbox_id = int(type_args[0])
    # Get the bounding box information
    bbox = state["bboxes"][bbox_id]
    # Extract x and y coordinates from the bounding box
    x, y = bbox["x"], bbox["y"]
    # Get the text to be typed
    text_content = type_args[1]
    # Click on the element at the specified coordinates
    await page.mouse.click(x, y)
    # Determine the "Select All" keyboard shortcut based on the operating system
    select_all = "Meta+A" if platform.system() == "Darwin" else "Control+A"
    # Select all existing text in the element
    await page.keyboard.press(select_all)
    # Delete the selected text
    await page.keyboard.press("Backspace")
    # Type the new text content
    await page.keyboard.type(text_content)
    # Press Enter to submit the input
    await page.keyboard.press("Enter")
    # Return a success message
    return f"Typed {text_content} and submitted"


async def scroll(state: AgentState):
    page = state["page"]
    scroll_args = state["prediction"]["args"]
    if scroll_args is None or len(scroll_args) != 2:
        return "Failed to scroll due to incorrect arguments."

    # unpack scroll arguments into target and direction
    target, direction = scroll_args

    # check if the scroll target is the entire window
    if target.upper() == "WINDOW":
        # set scroll amount for window scrolling
        scroll_amount = 500
        # determine scroll direction based on 'up' or 'down'
        scroll_direction = -scroll_amount if direction.lower() == "up" else scroll_amount
        # execute javascript to scroll the window
        await page.evaluate(f"window.scrollBy(0, {scroll_direction})")
    else:
        # set scroll amount for element scrolling
        scroll_amount = 200
        # convert target to integer for bounding box lookup
        target_id = int(target)
        # get bounding box for the target element
        bbox = state["bboxes"][target_id]
        # extract x and y coordinates from bounding box
        x, y = bbox["x"], bbox["y"]
        # determine scroll direction based on 'up' or 'down'
        scroll_direction = -scroll_amount if direction.lower() == "up" else scroll_amount
        # move mouse to the target element
        await page.mouse.move(x, y)
        # perform scroll action on the element
        await page.mouse.wheel(0, scroll_direction)

    return f"Scrolled {direction} in {'window' if target.upper() == 'WINDOW' else 'element'}"

async def wait(state: AgentState):
    sleep_time = 5
    # asyncio allows other funcs to continue while waiting
    await asyncio.sleep(sleep_time)
    return f"Waited for {sleep_time}s."

async def go_back(state: AgentState):
    page = state["page"]
    # playwright function
    await page.go_back()
    return f"Navigated back a page to {page.url}."

async def to_google(state: AgentState):
    page = state["page"]
    await page.goto("https://www.google.com/")
    return "Navigated to google.com."

# Define mark_page function, THIS MARKS BOUNDING BOXES.
# done with the mark_page.js file
# Read mark_page.js
with open("/Users/williamphan/Desktop/tour/app/api/parse/mark_page.js") as f:
    mark_page_script = f.read()

# decorator for chaining operations
# a way to wrap a function with another function, adding functionality before 
# or after the wrapped function executes
@chain_decorator
# asynchronous function to mark elements on the page
async def mark_page(page):
    # execute the marking script on the page
    await page.evaluate(mark_page_script)
    # try to mark the page up to 10 times
    for _ in range(10):
        try:
            # execute the markPage function and get bounding boxes
            bboxes = await page.evaluate("markPage()")
            # exit loop if successful
            break
        except:
            # wait for 3 seconds before retrying
            await asyncio.sleep(2)
    # take a screenshot of the marked page
    screenshot = await page.screenshot()
    # # remove the markings from the page
    # await page.evaluate("unmarkPage()")
    # return the screenshot and bounding boxes
    return {
        # encode the screenshot as base64
        "img": base64.b64encode(screenshot).decode(),
        # return the bounding boxes
        "bboxes": bboxes,
    }


# Define agent functions
async def annotate(state):
    marked_page = await mark_page.with_retry().ainvoke(state["page"])
    # Don't unmark the page here
    return {**state, **marked_page}


# define function that takes a state parameter
def format_descriptions(state):
    # initialize an empty list to store formatted labels
    labels = []
    # iterate over bounding boxes in state, with index
    for i, bbox in enumerate(state["bboxes"]):
        # get ariaLabel if it exists, otherwise empty string
        text = bbox.get("ariaLabel") or ""
        # if text is empty or only whitespace, use bbox text instead
        if not text.strip():
            text = bbox["text"]
        # get the type of the element
        el_type = bbox.get("type")
        # append formatted string to labels list
        labels.append(f'{i} (<{el_type}/>): "{text}"')
    # create a string of all labels, joined by newlines
    bbox_descriptions = "\nValid Bounding Boxes:\n" + "\n".join(labels)
    # return updated state with new bbox_descriptions
    return {**state, "bbox_descriptions": bbox_descriptions}


def parse(text: str) -> dict:
    action_prefix = "Action: "
    if not text.strip().split("\n")[-1].startswith(action_prefix):
        return {"action": "retry", "args": f"Could not parse LLM Output: {text}"}
    action_block = text.strip().split("\n")[-1]

    action_str = action_block[len(action_prefix):]
    split_output = action_str.split(" ", 1)
    if len(split_output) == 1:
        action, action_input = split_output[0], None
    else:
        action, action_input = split_output
    action = action.strip()
    if action_input is not None:
        action_input = [inp.strip().strip("[]") for inp in action_input.strip().split(";")]
    return {"action": action, "args": action_input}


"""
crucial for maintaining the agent's "memory" and providing it with a structured history of its interactions. This history is vital for the agent to perform complex, multi-step tasks on web pages, as it allows the agent to reference past actions, understand the current context, and make more informed decisions about what to do next.
"""

def update_scratchpad(state: AgentState):
    # Get the existing scratchpad from the state, if any
    old = state.get("scratchpad")
    
    if old:
        # If there's an existing scratchpad, get its content
        txt = old[0].content
        # Extract the last line of the existing content
        last_line = txt.rsplit("\n", 1)[-1]
        # Extract the step number from the last line and increment it
        step = int(re.match(r"\d+", last_line).group()) + 1
    else:
        # If there's no existing scratchpad, initialize with a header
        txt = "Previous action observations:\n"
        # Start with step 1
        step = 1
    
    # Add the new observation to the text, with the current step number
    txt += f"\n{step}. {state['observation']}"

    # Return updated state with new scratchpad content
    # The scratchpad is a list containing a single SystemMessage
    return {**state, "scratchpad": [SystemMessage(content=txt)]}

# Set up the agent
prompt = hub.pull("wfh/web-voyager")
llm = ChatOpenAI(model="gpt-4-turbo-2024-04-09", max_tokens=4096)
agent = annotate | RunnablePassthrough.assign(
    # | is used to chain operations together in order
    # StrOutputParser() parses into string, parse processes stirng output into structured format.
    prediction=format_descriptions | prompt | llm | StrOutputParser() | parse
)

####################
# INITIALIZE GRAPH #
####################

# Set up/initialize the graph, pass in the agent state
graph_builder = StateGraph(AgentState)
# define node
graph_builder.add_node("agent", agent)
# sents the agent node to be first node to be excecuted when running
graph_builder.set_entry_point("agent")
# define other node
graph_builder.add_node("update_scratchpad", update_scratchpad)
# define edge between both the nodes
# Agent makes a decision
# An action is taken based on that decision
# The scratchpad is updated with the result of that action
# Control returns to the agent for the next decision
graph_builder.add_edge("update_scratchpad", "agent")

# agent tools
tools = {
    "Click": click,
    "Type": type_text,
    "Scroll": scroll,
    "Wait": wait,
    "GoBack": go_back,
    "Google": to_google,
}

# Add nodes for each tool and connect them to the scratchpad update
for node_name, tool in tools.items():
    graph_builder.add_node(
        node_name,
        # Combine tool execution with formatting its output
        RunnableLambda(tool) | (lambda observation: {"observation": observation}),
    )
    # After each tool execution, update the scratchpad
    graph_builder.add_edge(node_name, "update_scratchpad")

# Function to select the next action based on the agent's prediction
def select_tool(state: AgentState):
    action = state["prediction"]["action"]
    if action == "ANSWER":
        return END  # End the process if the action is to answer
    if action == "retry":
        return "agent"  # Go back to the agent if a retry is needed
    return action  # Otherwise, return the action name (corresponding to a tool)

# Add conditional edges from the agent to other nodes based on select_tool function
graph_builder.add_conditional_edges("agent", select_tool)

# Compile the graph, making it ready for execution
graph = graph_builder.compile()

#############
# RUN AGENT #
#############

# Main function to run the agent
import asyncio
from playwright.async_api import Page

async def run_agent():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        page = await browser.new_page()
        await page.goto("https://www.google.com")

        async def call_agent(question: str, page: Page, max_steps: int = 150):
            pinecone_results = query_pinecone(question)
            relevant_info = "\n".join([result['metadata']['content'] for result in pinecone_results['matches']])
            augmented_input = f"{question}\n\nRelevant information from Firecrawl docs:\n{relevant_info}"

            state = {
                "page": page,
                "input": augmented_input,
                "scratchpad": [],
            }

            step_count = 1
            last_content = await page.content()

            print(f"\nQuestion: {question}")
            print("Tour Guide: Let's start by observing the current page.")

            while step_count <= max_steps:
                # Wait for page changes
                try:
                    await page.wait_for_function(
                        "document.body.innerHTML !== arguments[0]",
                        last_content,
                        timeout=30000
                    )
                except:
                    print("No page changes detected. Continuing...")

                # Update last_content
                last_content = await page.content()

                # Observe the current page state
                state = await annotate(state)
                state = format_descriptions(state)

                # Get agent's next action
                agent_output = await agent.ainvoke(state)
                pred = agent_output.get("prediction") or {}
                action = pred.get("action")
                action_input = pred.get("args")
                thought = agent_output.get("output", "").split("Thought:", 1)[-1].split("Action:", 1)[0].strip()

                print(f"\nStep {step_count}:")
                print(f"Tour Guide: Here's what I'm observing - {thought}")

                if "ANSWER" in action:
                    print(f"Tour Guide: I've found the answer: {action_input[0]}")
                    return action_input[0]

                instruction = get_instruction(action, action_input, state)
                print(f"Tour Guide: {instruction}")

                # Wait for the user to perform the action
                await asyncio.sleep(1)  # Small delay to prevent rapid-fire instructions
                
                step_count += 1

            return "Max steps reached without finding an answer."

        questions = [
            "What are the latest blog posts from langchain?",
        ]

        for question in questions:
            res = await call_agent(question, page)
            print(f"Final response: {res}\n")

        await browser.close()

def get_instruction(action, action_input, state):
    if action == "Click":
        bbox = state["bboxes"][int(action_input[0])]
        element_description = bbox.get("ariaLabel") or bbox.get("text") or f"element of type {bbox.get('type')}"
        return f"Please click on the {element_description}."
    elif action == "Type":
        bbox = state["bboxes"][int(action_input[0])]
        element_description = bbox.get("ariaLabel") or bbox.get("text") or f"input field of type {bbox.get('type')}"
        return f"Please type '{action_input[1]}' into the {element_description}."
    elif action == "Scroll":
        direction = "up" if action_input[1].lower() == "up" else "down"
        if action_input[0].upper() == "WINDOW":
            return f"Please scroll {direction} on the page."
        else:
            bbox = state["bboxes"][int(action_input[0])]
            element_description = bbox.get("ariaLabel") or bbox.get("text") or f"element of type {bbox.get('type')}"
            return f"Please scroll {direction} in the {element_description}."
    elif action == "Wait":
        return "Please wait for a moment while the page loads."
    elif action == "GoBack":
        return "Please go back to the previous page."
    elif action == "Google":
        return "Let's start over. Please go to Google's homepage."
    else:
        return f"Please {action} {action_input}"

# Run the agent
if __name__ == "__main__":
    asyncio.run(run_agent())